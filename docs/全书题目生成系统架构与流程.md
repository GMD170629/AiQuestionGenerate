# 全书题目生成系统架构与流程文档

## 目录

1. [系统概述](#系统概述)
2. [系统架构图](#系统架构图)
3. [核心模块](#核心模块)
4. [完整流程](#完整流程)
5. [数据模型](#数据模型)
6. [API 接口](#api-接口)
7. [前端交互流程](#前端交互流程)
8. [关键技术点](#关键技术点)

---

## 系统概述

全书题目生成系统是 AI 计算机教材习题生成器的核心功能模块，负责自动化处理整本教材的所有 Markdown 文件，批量生成高质量题目，并实时反馈处理进度。

### 主要功能

1. **批量文件处理**：自动遍历教材下的所有 Markdown 文件
2. **智能题目生成**：基于知识点提取结果，自适应生成多种类型的题目
3. **实时进度追踪**：通过 SSE (Server-Sent Events) 实时推送任务进度
4. **任务生命周期管理**：支持任务的创建、暂停、恢复、取消等操作
5. **持久化存储**：将生成的题目保存到数据库，关联到对应的文件和教材

### 技术特点

- **异步处理**：使用 FastAPI BackgroundTasks 实现后台任务处理
- **流式推送**：基于 SSE 实现实时进度更新，无需轮询
- **状态管理**：完善的任务状态机，支持 PENDING → PROCESSING → COMPLETED/FAILED/CANCELLED
- **错误恢复**：单个文件处理失败不影响整体任务执行
- **自适应出题**：AI 根据知识点内容自动决定题型和数量

---

## 系统架构图

### 整体架构

```mermaid
graph TB
    subgraph "前端层 (Next.js + React)"
        A[任务中心页面<br/>tasks/page.tsx]
        B[任务进度监控组件<br/>TaskProgressMonitor.tsx]
        C[任务行组件<br/>TaskRow.tsx]
        D[useTaskStream Hook<br/>useTaskStream.ts]
    end
    
    subgraph "API 层 (FastAPI)"
        E[任务管理路由<br/>routers/tasks.py]
        F[题目生成路由<br/>routers/questions.py]
    end
    
    subgraph "服务层 (Service Layer)"
        G[任务处理服务<br/>services/task_service.py]
        H[文件服务<br/>services/file_service.py]
    end
    
    subgraph "业务逻辑层"
        I[Markdown处理器<br/>md_processor.py]
        J[题目生成器<br/>generator.py]
        K[任务管理器<br/>task_manager.py]
        L[进度管理器<br/>task_progress.py]
    end
    
    subgraph "数据持久层"
        M[(SQLite 数据库<br/>database.py)]
    end
    
    subgraph "外部服务"
        N[OpenRouter API<br/>AI 模型服务]
    end
    
    A -->|1. 选择教材,启动任务| E
    E -->|2. 创建任务,启动后台任务| G
    G -->|3. 遍历文件| I
    I -->|4. 文本切片| G
    G -->|5. 生成题目| J
    J -->|6. 调用 AI| N
    N -->|7. 返回题目| J
    J -->|8. 保存题目| G
    G -->|9. 更新进度| L
    L -->|10. SSE 推送| E
    E -->|11. 流式响应| D
    D -->|12. 更新 UI| B
    B -->|13. 显示进度| A
    
    G -->|持久化任务状态| M
    G -->|持久化题目数据| M
    K -->|管理任务状态| G
    E -->|任务控制操作| K
    E -->|SSE 连接| L
```

### 模块交互流程

```mermaid
sequenceDiagram
    participant U as 用户
    participant F as 前端页面
    participant API as Tasks Router
    participant BG as Background Tasks
    participant TS as Task Service
    participant TM as Task Manager
    participant PM as Progress Manager
    participant MP as Markdown Processor
    participant GN as Question Generator
    participant DB as Database
    participant AI as OpenRouter API
    
    U->>F: 1. 选择教材,点击"开始全书出题"
    F->>API: 2. POST /tasks/generate-book
    API->>DB: 3. 创建 Task 记录
    API->>BG: 4. 启动后台任务
    API->>F: 5. 返回 task_id
    F->>API: 6. 建立 SSE 连接 GET /tasks/{task_id}/progress
    
    BG->>TS: 7. 调用 process_full_textbook_task
    TS->>TM: 8. 注册任务
    TS->>DB: 9. 获取教材和文件列表
    
    loop 遍历每个文件
        TS->>PM: 10. 推送进度: 开始处理文件 X
        PM->>F: 11. SSE: 进度更新
        TS->>MP: 12. 处理文件切片
        MP->>TS: 13. 返回切片列表
        
        loop 遍历每个切片
            TS->>TM: 14. 检查任务状态(暂停/取消)
            TS->>GN: 15. 生成题目(自适应模式)
            GN->>AI: 16. 调用 AI API
            AI->>GN: 17. 返回题目数据
            GN->>TS: 18. 返回题目列表
            TS->>DB: 19. 保存题目到数据库
            TS->>PM: 20. 推送进度: 切片 X/Y 完成
            PM->>F: 21. SSE: 进度更新
        end
    end
    
    TS->>DB: 22. 更新任务状态为 COMPLETED
    TS->>PM: 23. 推送完成状态
    PM->>F: 24. SSE: 任务完成
    F->>U: 25. 显示完成提示
```

---

## 核心模块

### 后端模块

| 模块 | 文件路径 | 职责 | 关键方法 |
|------|---------|------|---------|
| **任务路由** | `backend/routers/tasks.py` | 提供任务管理 API 接口 | `generate_book()`, `get_task_progress()`, `pause_task()`, `resume_task()`, `cancel_task()` |
| **任务处理服务** | `backend/services/task_service.py` | 执行全书题目生成的核心业务逻辑 | `process_full_textbook_task()` |
| **任务管理器** | `backend/task_manager.py` | 管理任务生命周期，支持暂停/恢复/取消 | `register_task()`, `pause_task()`, `resume_task()`, `cancel_task()`, `check_and_wait()` |
| **进度管理器** | `backend/task_progress.py` | 管理任务进度推送队列，支持多客户端订阅 | `register_queue()`, `push_progress()`, `get_last_state()` |
| **Markdown 处理器** | `backend/md_processor.py` | 解析 Markdown 文件，按层级切片 | `process()`, `get_chapter_name()` |
| **题目生成器** | `backend/generator.py` | 调用 AI 生成题目 | `generate_questions_for_chunk()` |
| **数据库操作** | `backend/database.py` | 任务和题目的 CRUD 操作 | `create_task()`, `update_task()`, `store_question()`, `get_task()` |

### 前端模块

| 模块 | 文件路径 | 职责 | 关键功能 |
|------|---------|------|---------|
| **任务中心页面** | `frontend/app/tasks/page.tsx` | 任务列表展示和任务创建 | 教材选择、任务列表、任务操作 |
| **任务进度监控** | `frontend/components/TaskProgressMonitor.tsx` | 实时显示任务进度 | SSE 连接、进度条、日志显示 |
| **任务行组件** | `frontend/components/TaskRow.tsx` | 单个任务行的展示和操作 | 暂停/恢复/取消按钮、进度显示 |
| **任务流 Hook** | `frontend/hooks/useTaskStream.ts` | 封装 SSE 连接逻辑 | 自动重连、状态管理、日志记录 |

---

## 完整流程

### 1. 任务创建阶段

```mermaid
flowchart TD
    A[用户选择教材] --> B{检查教材是否存在}
    B -->|否| C[返回错误: 教材不存在]
    B -->|是| D{检查是否有 MD 文件}
    D -->|否| E[返回错误: 无 Markdown 文件]
    D -->|是| F[生成 task_id]
    F --> G[在数据库中创建 Task 记录<br/>状态: PENDING]
    G --> H[使用 BackgroundTasks 启动后台任务]
    H --> I[立即返回 task_id 给前端]
    I --> J[前端建立 SSE 连接]
```

**关键代码位置**：
- `backend/routers/tasks.py:445-508` - `generate_book()` 函数

### 2. 任务执行阶段

```mermaid
flowchart TD
    A[后台任务开始] --> B[注册任务到 TaskManager]
    B --> C[获取教材信息和文件列表]
    C --> D[更新任务状态: PROCESSING]
    D --> E[初始化 MarkdownProcessor]
    E --> F{是否有文件需要处理}
    
    F -->|否| Z[任务完成]
    F -->|是| G[获取下一个文件]
    
    G --> H[检查任务状态]
    H -->|已取消| Z
    H -->|已暂停| I[等待恢复]
    I --> H
    H -->|正常| J[处理文件切片]
    
    J --> K{是否还有切片}
    K -->|否| L[文件处理完成]
    K -->|是| M[获取下一个切片]
    
    M --> N[检查任务状态]
    N -->|已取消| Z
    N -->|已暂停| O[等待恢复]
    O --> N
    N -->|正常| P[调用 AI 生成题目]
    
    P --> Q{生成成功?}
    Q -->|否| R[记录错误,继续下一个切片]
    Q -->|是| S[保存题目到数据库]
    
    S --> T[更新进度<br/>文件级别 + 切片级别]
    T --> U[推送进度到 ProgressManager]
    U --> M
    
    R --> M
    L --> F
    
    Z --> AA[更新任务状态: COMPLETED]
    AA --> BB[推送完成消息]
```

**关键代码位置**：
- `backend/services/task_service.py:17-287` - `process_full_textbook_task()` 函数
- `backend/task_manager.py:152-173` - `check_and_wait()` 方法

### 3. 题目生成阶段

```mermaid
flowchart TD
    A[接收切片数据] --> B[提取章节信息]
    B --> C[构建知识点上下文]
    C --> D[随机决定题目数量<br/>1-2 道]
    D --> E[启用自适应模式<br/>question_types=]
    E --> F[限制难度: 中等/困难]
    F --> G[构建 Prompt]
    G --> H[调用 OpenRouter API]
    H --> I{API 调用成功?}
    
    I -->|否| J[重试或返回空列表]
    I -->|是| K[解析 AI 返回的 JSON]
    K --> L{解析成功?}
    
    L -->|否| J
    L -->|是| M[验证题目格式]
    M --> N[添加章节信息]
    N --> O[返回题目列表]
```

**关键代码位置**：
- `backend/generator.py:1884-1944` - `generate_questions_for_chunk()` 函数
- `backend/generator.py:1267-1371` - `_generate_batch()` 方法

### 4. 进度推送阶段

```mermaid
flowchart TD
    A[TaskService 更新进度] --> B[调用 ProgressManager.push_progress]
    B --> C[更新最后状态缓存]
    C --> D[构建进度数据对象]
    D --> E{是否有订阅队列?}
    
    E -->|否| F[仅更新状态缓存]
    E -->|是| G[遍历所有订阅队列]
    
    G --> H[将进度数据放入队列]
    H --> I[SSE Generator 从队列读取]
    I --> J[格式化 JSON 数据]
    J --> K[通过 SSE 发送给前端]
    K --> L[前端 EventSource 接收]
    L --> M[更新 UI 状态]
    
    M --> N{任务是否完成?}
    N -->|否| I
    N -->|是| O[关闭 SSE 连接]
```

**关键代码位置**：
- `backend/task_progress.py:64-110` - `push_progress()` 方法
- `backend/routers/tasks.py:22-125` - `get_task_progress()` 函数

---

## 数据模型

### Task 数据模型

```python
{
    "task_id": str,              # UUID, 主键
    "textbook_id": str,          # 教材 ID, 外键
    "status": str,               # 状态: PENDING | PROCESSING | PAUSED | COMPLETED | FAILED | CANCELLED
    "progress": float,           # 进度: 0.0 - 1.0
    "current_file": str | None,  # 当前处理的文件名
    "total_files": int,          # 总文件数
    "error_message": str | None, # 错误消息（如果失败）
    "created_at": str,           # ISO 格式时间戳
    "updated_at": str            # ISO 格式时间戳
}
```

**数据库表结构**：
- 表名：`generation_tasks`
- 关键字段：`task_id` (PRIMARY KEY), `textbook_id`, `status`, `progress`, `current_file`

### Question 数据模型

```python
{
    "question_id": str,          # UUID, 主键
    "task_id": str,              # 关联的任务 ID
    "file_id": str,              # 关联的文件 ID
    "textbook_id": str,          # 关联的教材 ID
    "question_type": str,        # 题型: single_choice | multiple_choice | true_false | fill_blank
    "question": str,             # 题目内容
    "options": List[str],        # 选项列表（选择题）
    "correct_answer": str | List[str],  # 正确答案
    "explanation": str,          # 解析
    "difficulty": str,           # 难度: 简单 | 中等 | 困难
    "chapter": str | None,       # 章节名称
    "source_file": str,          # 源文件名
    "file_path": str,            # 文件路径
    "created_at": str            # ISO 格式时间戳
}
```

**数据库表结构**：
- 表名：`questions`
- 关键字段：`question_id` (PRIMARY KEY), `task_id`, `file_id`, `textbook_id`

### 进度推送数据模型

```python
{
    "status": str,               # 状态: connected | progress | COMPLETED | FAILED | CANCELLED
    "progress": float,           # 进度: 0.0 - 1.0
    "percentage": float,         # 百分比: 0.0 - 100.0
    "current_file": str | None,  # 当前处理的文件名
    "message": str | None,       # 进度消息
    "timestamp": str             # ISO 格式时间戳
}
```

---

## API 接口

### 1. 启动全书题目生成

**接口**: `POST /tasks/generate-book`

**请求体**:
```json
{
    "textbook_id": "uuid-string"
}
```

**响应**:
```json
{
    "message": "任务已启动",
    "task_id": "uuid-string",
    "task": {
        "task_id": "uuid-string",
        "textbook_id": "uuid-string",
        "status": "PENDING",
        "progress": 0.0,
        "total_files": 10,
        ...
    }
}
```

### 2. 获取任务进度 (SSE)

**接口**: `GET /tasks/{task_id}/progress`

**响应类型**: `text/event-stream`

**事件格式**:
```
data: {"status": "connected", "progress": 0.0, "percentage": 0.0, ...}

data: {"status": "progress", "progress": 0.35, "percentage": 35.0, "current_file": "第二章.md", ...}

data: {"status": "COMPLETED", "progress": 1.0, "percentage": 100.0, ...}
```

### 3. 获取任务详情

**接口**: `GET /tasks/{task_id}`

**响应**:
```json
{
    "task_id": "uuid-string",
    "textbook_id": "uuid-string",
    "status": "PROCESSING",
    "progress": 0.35,
    "current_file": "第二章.md",
    "total_files": 10,
    ...
}
```

### 4. 获取任务列表

**接口**: `GET /tasks?textbook_id={textbook_id}&status={status}&limit={limit}&offset={offset}`

**响应**:
```json
[
    {
        "task_id": "uuid-string",
        "textbook_id": "uuid-string",
        "status": "COMPLETED",
        "progress": 1.0,
        ...
    },
    ...
]
```

### 5. 暂停任务

**接口**: `POST /tasks/{task_id}/pause`

**响应**:
```json
{
    "message": "任务已暂停",
    "task_id": "uuid-string",
    "status": "PAUSED"
}
```

### 6. 恢复任务

**接口**: `POST /tasks/{task_id}/resume`

**响应**:
```json
{
    "message": "任务已恢复",
    "task_id": "uuid-string",
    "status": "PROCESSING"
}
```

### 7. 取消任务

**接口**: `POST /tasks/{task_id}/cancel`

**响应**:
```json
{
    "message": "任务已取消",
    "task_id": "uuid-string",
    "status": "CANCELLED"
}
```

---

## 前端交互流程

### 1. 任务创建流程

```mermaid
sequenceDiagram
    participant U as 用户
    participant P as TasksPage
    participant API as API Client
    participant S as Server
    
    U->>P: 选择教材
    U->>P: 点击"开始全书出题"
    P->>API: POST /tasks/generate-book
    API->>S: 发送请求
    S->>API: 返回 task_id
    API->>P: 返回响应
    P->>P: 显示成功提示
    P->>P: 刷新任务列表
    P->>P: 可选: 打开任务详情查看进度
```

### 2. 进度监控流程

```mermaid
sequenceDiagram
    participant P as TasksPage
    participant T as TaskRow
    participant H as useTaskStream
    participant SSE as EventSource
    participant S as Server
    
    P->>T: 渲染任务行
    T->>H: 调用 useTaskStream(taskId)
    H->>SSE: 创建 EventSource 连接
    SSE->>S: GET /tasks/{taskId}/progress
    
    S->>SSE: 发送初始状态
    SSE->>H: onmessage: 初始状态
    H->>T: 更新 progress state
    
    loop 任务执行中
        S->>SSE: 发送进度更新
        SSE->>H: onmessage: 进度数据
        H->>H: 更新 progress, 添加日志
        H->>T: 触发 state 更新
        T->>T: 重新渲染进度条和日志
    end
    
    S->>SSE: 发送完成状态
    SSE->>H: onmessage: COMPLETED
    H->>T: 更新 status 为 COMPLETED
    H->>SSE: 关闭连接
    T->>T: 显示完成图标
    T->>P: 触发 onTaskComplete 回调
    P->>P: 刷新任务列表
```

### 3. 任务控制流程

```mermaid
sequenceDiagram
    participant U as 用户
    participant T as TaskRow
    participant API as API Client
    participant S as Server
    participant TS as Task Service
    
    U->>T: 点击"暂停"按钮
    T->>API: POST /tasks/{taskId}/pause
    API->>S: 发送请求
    S->>TS: 调用 TaskManager.pause_task()
    TS->>TS: 设置暂停标志
    TS->>S: 更新数据库状态为 PAUSED
    S->>API: 返回成功
    API->>T: 返回响应
    T->>T: 更新按钮为"恢复"
    T->>T: 显示暂停状态
    
    Note over TS: 任务在 check_and_wait() 处等待
    
    U->>T: 点击"恢复"按钮
    T->>API: POST /tasks/{taskId}/resume
    API->>S: 发送请求
    S->>TS: 调用 TaskManager.resume_task()
    TS->>TS: 清除暂停标志
    TS->>S: 更新数据库状态为 PROCESSING
    S->>API: 返回成功
    API->>T: 返回响应
    T->>T: 更新按钮为"暂停"
    T->>T: 显示执行中状态
    
    Note over TS: 任务继续执行
```

---

## 关键技术点

### 1. 异步任务处理

**技术选型**: FastAPI BackgroundTasks

**优势**:
- 简单易用，无需额外依赖（如 Celery）
- 与 FastAPI 无缝集成
- 适合中小规模任务

**实现要点**:
```python
# backend/routers/tasks.py
background_tasks.add_task(process_full_textbook_task, task_id)
```

### 2. Server-Sent Events (SSE)

**技术选型**: FastAPI StreamingResponse + asyncio.Queue

**实现架构**:
- `TaskProgressManager`: 管理进度队列，支持多客户端订阅
- `asyncio.Queue`: 每个客户端连接对应一个队列
- `StreamingResponse`: FastAPI 流式响应，发送 SSE 格式数据

**关键代码**:
```python
# backend/task_progress.py
async def push_progress(self, task_id: str, progress: float, ...):
    # 推送到所有订阅的队列
    for queue in self._task_queues[task_id]:
        await queue.put(progress_data)

# backend/routers/tasks.py
async def progress_generator():
    progress_queue = await task_progress_manager.register_queue(task_id)
    while True:
        progress_data = await progress_queue.get()
        yield f"data: {json.dumps(progress_data)}{newline}{newline}"
```

### 3. 任务状态管理

**状态机设计**:
```
PENDING → PROCESSING → COMPLETED
              ↓
           PAUSED (可恢复)
              ↓
          CANCELLED
              ↓
           FAILED
```

**实现机制**:
- `TaskManager`: 使用 `asyncio.Event` 实现暂停/恢复
- `check_and_wait()`: 在每个关键点检查任务状态
- 数据库持久化: 任务状态保存在数据库中，支持服务重启后恢复

### 4. 自适应题目生成

**策略**:
- 每个切片随机生成 1-2 道题目
- 不指定题型，让 AI 自主选择最适合的题型
- 限制难度为中等或困难，避免过于简单的题目

**实现**:
```python
# backend/generator.py
question_count = random.randint(1, 2)
questions_data = await client._generate_batch(
    context=context,
    batch_question_types=[],  # 空列表启用自适应模式
    batch_count=question_count,
    allowed_difficulties=["中等", "困难"]
)
```

### 5. 进度计算

**两级进度计算**:
- **文件级别进度**: `(file_index - 1) / total_files`
- **切片级别进度**: `chunk_index / total_chunks`
- **总体进度**: `文件级别进度 + (切片级别进度 / total_files)`

**公式**:
```
总体进度 = (file_index - 1) / total_files + (chunk_index / total_chunks) / total_files
```

### 6. 错误处理与容错

**策略**:
- 单个切片生成失败不影响其他切片
- 单个文件处理失败不影响其他文件
- 任务级别的错误会标记整个任务为 FAILED
- 所有错误都会记录到日志和数据库

**实现**:
```python
# backend/services/task_service.py
try:
    questions_data = await generate_questions_for_chunk(chunk, ...)
    # 保存题目
except Exception as e:
    print(f"警告：切片生成题目失败: {e}")
    continue  # 继续处理下一个切片
```

### 7. 性能优化

**限流控制**:
- 每个切片生成后添加 0.5 秒延迟，避免 API 限流
- 未来可改进为令牌桶算法

**资源管理**:
- SSE 连接断开时自动清理队列
- 任务完成后保留状态一段时间，便于新连接获取最后状态

---

## 总结

全书题目生成系统采用了清晰的**分层架构**和**异步处理**机制，实现了高效的批量题目生成功能。通过 **SSE 实时推送**、**完善的任务管理**和**自适应出题策略**，系统能够在处理大规模教材时保持良好的用户体验和系统稳定性。

### 设计亮点

1. ✅ **职责分离**: 路由层、服务层、业务逻辑层清晰划分
2. ✅ **实时反馈**: SSE 流式推送，用户体验优秀
3. ✅ **状态管理**: 完善的任务状态机，支持暂停/恢复/取消
4. ✅ **容错机制**: 单个失败不影响整体，任务可恢复
5. ✅ **可扩展性**: 模块化设计，易于扩展新功能

### 未来改进方向

1. 🔄 **令牌桶限流**: 替换简单延迟，实现更智能的 API 限流
2. 🔄 **任务优先级**: 支持任务优先级队列
3. 🔄 **并发控制**: 支持多个任务并发执行（需考虑资源限制）
4. 🔄 **断点续传**: 优化任务恢复逻辑，支持更精确的断点续传
5. 🔄 **批量优化**: 优化题目生成逻辑，支持批量生成以提高效率

