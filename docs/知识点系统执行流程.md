# 知识点系统执行流程文档

## 目录

1. [系统概述](#系统概述)
2. [核心模块](#核心模块)
3. [知识点提取流程](#知识点提取流程)
4. [知识图谱构建流程](#知识图谱构建流程)
5. [前端展示流程](#前端展示流程)
6. [数据模型](#数据模型)
7. [API 接口](#api-接口)

---

## 系统概述

知识点系统是 AI 计算机教材习题生成器的核心模块，负责从 Markdown 教材文件中提取知识点、构建知识图谱、建立层级关系和依赖关系，并支持前端可视化展示。

### 主要功能

1. **知识点提取**：从 Markdown 文件的每个切片中提取核心概念、易错点、Bloom 层级和应用场景
2. **知识图谱构建**：使用 NetworkX 构建知识点之间的依赖关系图
3. **可视化展示**：前端使用 vis-network 展示知识图谱

---

## 核心模块

### 后端模块

| 模块 | 文件路径 | 职责 |
|------|---------|------|
| 知识点提取 | `backend/md_processor.py` | 从切片中提取知识点元数据 |
| 知识图谱管理 | `backend/graph_manager.py` | 管理知识图谱的构建和查询 |
| 进度管理 | `backend/knowledge_extraction_progress.py` | 跟踪知识提取进度 |
| 提示词管理 | `backend/prompts/knowledge_extraction_prompts.py` | 管理 AI 提示词模板 |
| 路由处理 | `backend/routers/knowledge_extraction.py` | 知识提取进度 API |
| 路由处理 | `backend/routers/knowledge_graph.py` | 知识图谱查询 API |
| 数据库操作 | `backend/database.py` | 知识点节点的 CRUD 操作 |

### 前端模块

| 模块 | 文件路径 | 职责 |
|------|---------|------|
| 知识图谱组件 | `frontend/components/KnowledgeMap.tsx` | 可视化展示知识图谱 |
| 知识图谱页面 | `frontend/app/knowledge-map/page.tsx` | 知识图谱页面路由 |

---

## 知识点提取流程

### 1. 文件上传与解析

**入口**：`POST /api/files/upload` 或 `POST /api/files/{file_id}/parse`

**执行流程**：

```
文件上传
  ↓
保存到 uploads/ 目录
  ↓
调用 MarkdownProcessor.process() 解析文件
  ↓
按标题层级切分文件为 chunks
  ↓
存储 chunks 到数据库
  ↓
后台异步触发知识点提取
```

**关键代码**：

```python:backend/routers/files.py
# 在文件解析完成后，后台异步提取知识点
background_tasks.add_task(
    extract_and_store_knowledge_nodes,
    file_id=file_id
)
```

### 2. 知识点提取主流程

**入口函数**：`extract_and_store_knowledge_nodes()` (`backend/md_processor.py:658`)

**执行流程**：

```
1. 获取文件的所有 chunks（包含 chunk_id）
   ↓
2. 初始化进度管理器
   ↓
3. 遍历每个 chunk：
   a. 调用 LLM API 提取知识点元数据
   b. 检查是否重复（与已有知识点或当前批次）
   c. 如果未重复，存储到数据库
   d. 更新进度
   ↓
4. 重新加载知识图谱
   ↓
5. 完成并返回提取数量
```

**关键代码**：

```python:backend/md_processor.py
async def extract_and_store_knowledge_nodes(file_id: str, ...):
    # 1. 获取所有 chunks
    chunks_with_ids = db.get_file_chunks(file_id)
    
    # 2. 遍历提取
    for chunk_data in chunks_with_ids:
        # 调用 LLM 提取知识点
        knowledge_data = await processor.extract_knowledge_metadata(
            chunk_content, chunk_metadata, api_key, model, api_endpoint, file_id
        )
        
        # 检查重复并存储
        if not is_duplicate:
            db.store_knowledge_node(...)
```

### 3. LLM 知识点提取

**入口函数**：`extract_knowledge_metadata()` (`backend/md_processor.py:36`)

**执行流程**：

```
1. 获取上下文信息：
   - 文件名
   - 教材名称
   - 章节路径（Header 1/2/3）
   - 已有知识点列表（用于去重）
   ↓
2. 构建提示词：
   - System Prompt：知识点提取原则和格式要求
   - User Prompt：上下文 + 切片内容 + 已有知识点列表
   ↓
3. 调用 OpenRouter API
   ↓
4. 解析 JSON 响应：
   - core_concept: 核心概念
   - confusion_points: 易错点列表
   - bloom_level: Bloom 认知层级（1-6）
   - application_scenarios: 应用场景列表
   ↓
5. 验证和规范化数据
   ↓
6. 返回知识点元数据
```

**提示词模板**：

- System Prompt: `backend/prompts/knowledge_extraction_prompts.py:5`
- User Prompt: `backend/prompts/knowledge_extraction_prompts.py:67`

**关键原则**：

1. **只提取 1 个核心概念**：每个切片只提取最重要的核心概念
2. **避免重复**：检查已有知识点列表，使用相同名称
3. **标准命名**：使用计算机科学领域的标准术语
4. **独立性**：知识点应该是独立的，不包含前置依赖

### 4. 知识点存储

**数据库表**：`knowledge_nodes`

**存储字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| node_id | TEXT PRIMARY KEY | 节点唯一标识 |
| chunk_id | INTEGER | 关联的切片 ID |
| file_id | TEXT | 所属文件 ID |
| core_concept | TEXT | 核心概念名称 |
| level | INTEGER | 层级（1/2/3，默认 3） |
| parent_id | TEXT | 父节点 ID（可选） |
| prerequisites_json | TEXT | 前置依赖（JSON 数组，已废弃） |
| confusion_points_json | TEXT | 易错点列表（JSON 数组） |
| bloom_level | INTEGER | Bloom 认知层级（1-6） |
| application_scenarios_json | TEXT | 应用场景列表（JSON 数组） |
| created_at | TEXT | 创建时间 |

**存储函数**：`db.store_knowledge_node()` (`backend/database.py:1628`)

### 5. 进度跟踪

**进度管理器**：`KnowledgeExtractionProgressManager` (`backend/knowledge_extraction_progress.py`)

**进度更新时机**：

- 开始提取：初始化进度（0/total）
- 每个切片处理完成：更新进度（current/total）
- 完成或失败：最终状态

**进度数据结构**：

```json
{
  "current": 5,
  "total": 10,
  "progress": 0.5,
  "percentage": 50.0,
  "current_chunk": "切片 5",
  "message": "正在提取知识点: 进程同步... (5/10)",
  "status": "extracting",
  "timestamp": "2024-01-01T12:00:00"
}
```

**前端获取进度**：

- SSE 流式：`GET /api/knowledge-extraction/{file_id}/progress`
- 一次性查询：`GET /api/knowledge-extraction/{file_id}/status`

---

## 知识图谱构建流程

### 1. 图谱初始化

**管理器类**：`KnowledgeGraphManager` (`backend/graph_manager.py:22`)

**全局实例**：`knowledge_graph = KnowledgeGraphManager()` (`backend/graph_manager.py:480`)

**初始化状态**：

- `graph`: NetworkX DiGraph（有向图，初始为空）
- `concept_to_node_id`: 概念名称到节点 ID 的映射（初始为空）
- `concept_metadata`: 概念元数据字典（初始为空）
- `_is_loaded`: False（标记是否已从数据库加载）

**数据结构**：

- `graph`: NetworkX DiGraph（有向图）
- `concept_to_node_id`: 概念名称到节点 ID 的映射
- `concept_metadata`: 概念元数据字典

### 2. 知识图谱构建的触发机制

知识图谱的构建采用**懒加载机制**，有两种触发方式：

#### 方式一：懒加载（自动触发）

当首次调用查询方法时，如果 `_is_loaded` 为 `False`，会自动调用 `load_from_database()`。

**触发方法**：

| 方法 | 位置 | 说明 |
|------|------|------|
| `get_prerequisite_context()` | `graph_manager.py:262` | 获取前置知识点上下文 |
| `get_concept_info()` | `graph_manager.py:368` | 获取知识点详细信息 |
| `get_all_concepts()` | `graph_manager.py:405` | 获取所有知识点列表 |
| `get_graph_stats()` | `graph_manager.py:417` | 获取图谱统计信息 |
| `find_path()` | `graph_manager.py:435` | 查找知识点之间的路径 |
| `get_topological_order()` | `graph_manager.py:463` | 获取拓扑排序 |

**示例代码**：

```python:backend/graph_manager.py
def get_concept_info(self, concept_name: str):
    if not self._is_loaded:
        self.load_from_database()  # 自动触发加载
    # ... 后续查询逻辑
```

#### 方式二：显式触发（手动调用）

在以下场景中，会显式调用 `reload()` 方法强制重新加载图谱：

| 触发位置 | 文件 | 行号 | 触发时机 |
|---------|------|------|---------|
| 知识点提取完成 | `md_processor.py` | 910 | 新知识点提取完成后，确保新知识点可查询 |
| 获取图谱数据 API | `routers/knowledge_graph.py` | 34 | 前端请求图谱数据时，确保数据最新 |
| 获取知识点列表 API | `routers/knowledge_graph.py` | 288 | 获取所有知识点列表时 |
| 获取统计信息 API | `routers/knowledge_graph.py` | 333 | 获取图谱统计信息时 |

**关键代码**：

```python:backend/md_processor.py
# 知识点提取完成后重新加载
knowledge_graph.reload()
print(f"知识图谱已重新加载，当前节点数: {knowledge_graph.graph.number_of_nodes()}")
```

```python:backend/routers/knowledge_graph.py
# API 请求时重新加载（确保数据最新）
node_count = knowledge_graph.reload()
```

### 3. 从数据库加载图谱

**入口函数**：`load_from_database()` (`backend/graph_manager.py:33`)

**调用方式**：

- 直接调用：`knowledge_graph.load_from_database()`
- 通过 `reload()` 调用：`knowledge_graph.reload()` → `load_from_database()`

**执行流程**：

```
1. 清空现有图（graph.clear()）
   ↓
2. 清空映射和元数据（concept_to_node_id, concept_metadata 等）
   ↓
3. 从数据库获取所有知识点节点
   SQL: SELECT * FROM knowledge_nodes ORDER BY created_at ASC
   ↓
4. 第一遍：创建所有节点
   - 遍历每个知识点节点
   - 如果概念已存在，合并元数据（保留更早的节点ID）
   - 如果概念不存在，创建新节点
   - 存储到 graph、concept_to_node_id、concept_metadata
   ↓
5. 第二遍：创建边（依赖关系）
   a. 基于 knowledge_dependencies 表创建依赖关系边
   b. 基于 prerequisites_json（向后兼容）创建前置依赖关系边
   - 如果前置知识点存在，创建边：prereq -> core_concept（depends_on）
   - 如果前置知识点不存在，创建临时节点并建立边
   ↓
6. 设置 _is_loaded = True
   ↓
7. 返回节点数量
```

**关键代码**：

```python:backend/graph_manager.py
def load_from_database(self) -> int:
    # 清空现有图
    self.graph.clear()
    self.concept_to_node_id.clear()
    self.concept_metadata.clear()
    
    # 从数据库获取所有知识点节点
    rows = db.get_all_knowledge_nodes()
    
    # 第一遍：创建所有节点
    for row in rows:
        core_concept = row["core_concept"]
        if core_concept in self.concept_to_node_id:
            # 合并元数据
            ...
        else:
            # 创建新节点
            self.graph.add_node(core_concept, **metadata)
    
    # 第二遍：创建边
    for row in rows:
        prerequisites = json.loads(row["prerequisites_json"])
        for prereq in prerequisites:
            self.graph.add_edge(prereq, core_concept, relation="depends_on")
    
    self._is_loaded = True
    return len(self.graph.nodes())
```

**关键代码**：

```python:backend/graph_manager.py
def load_from_database(self) -> int:
    # 清空图
    self.graph.clear()
    
    # 获取所有节点
    rows = db.get_all_knowledge_nodes()
    
    # 第一遍：创建节点
    for row in rows:
        core_concept = row["core_concept"]
        if core_concept in self.concept_to_node_id:
            # 合并元数据
            ...
        else:
            # 创建新节点
            self.graph.add_node(core_concept, **metadata)
    
    # 第二遍：创建边
    for row in rows:
        prerequisites = json.loads(row["prerequisites_json"])
        for prereq in prerequisites:
            self.graph.add_edge(prereq, core_concept, relation="depends_on")
```

### 4. 图谱查询方法

**主要方法**：

| 方法 | 说明 |
|------|------|
| `get_prerequisite_context()` | 获取前置知识点上下文（BFS 回溯） |
| `get_concept_info()` | 获取知识点详细信息 |
| `get_all_concepts()` | 获取所有知识点列表 |
| `get_graph_stats()` | 获取图谱统计信息 |
| `find_path()` | 查找两个知识点之间的路径 |
| `get_topological_order()` | 获取拓扑排序 |

**使用示例**：

```python
from graph_manager import knowledge_graph

# 方式一：自动加载（首次调用时，如果 _is_loaded=False）
prerequisites = knowledge_graph.get_prerequisite_context("死锁", max_depth=3, max_concepts=3)
# ↑ 内部会自动调用 load_from_database()

# 方式二：手动重新加载（强制刷新）
knowledge_graph.reload()  # 调用 reload() → load_from_database()

# 获取知识点信息（如果已加载，直接查询；否则自动加载）
info = knowledge_graph.get_concept_info("死锁")
```

### 5. 触发时机总结

**知识图谱构建的完整触发流程**：

```
应用启动
  ↓
创建全局实例 knowledge_graph（_is_loaded = False）
  ↓
等待触发...
  ↓
触发方式一：首次查询（懒加载）
  - 调用 get_concept_info() 等方法
  - 检查 _is_loaded == False
  - 自动调用 load_from_database()
  ↓
触发方式二：显式重新加载
  - 知识点提取完成后：knowledge_graph.reload()
  - API 请求时：knowledge_graph.reload()
  - 调用 reload() → load_from_database()
  ↓
load_from_database() 执行
  - 从数据库加载所有知识点
  - 构建 NetworkX 图
  - 设置 _is_loaded = True
  ↓
图谱构建完成，可用于查询
```

**最佳实践**：

1. **首次使用**：直接调用查询方法，会自动懒加载
2. **数据更新后**：显式调用 `reload()` 确保数据最新
3. **API 请求**：每次请求时调用 `reload()` 保证数据一致性

---

## 前端展示流程

### 1. 知识图谱页面

**页面路由**：`/knowledge-map` (`frontend/app/knowledge-map/page.tsx`)

**功能**：

- 选择教材或文件进行筛选
- 显示知识图谱可视化
- 点击节点查看详细信息

### 2. 知识图谱组件

**组件**：`KnowledgeMap` (`frontend/components/KnowledgeMap.tsx`)

**执行流程**：

```
1. 组件挂载
   ↓
2. 调用 API 获取图谱数据：
   GET /api/knowledge-graph/graph-data?file_id=xxx&textbook_id=xxx
   ↓
3. 处理数据：
   - 根据 file_id 或 textbook_id 筛选节点
   - 限制节点数量（max_nodes）
   - 构建节点和边的数据结构
   ↓
4. 初始化 vis-network：
   - 创建 DataSet（nodes, edges）
   - 配置可视化选项
   - 渲染网络图
   ↓
5. 交互处理：
   - 节点点击：显示详细信息面板
   - 层级筛选：按 Level 1/2/3 筛选
   - 缩放和拖拽
```

### 3. 数据获取 API

**API 端点**：`GET /api/knowledge-graph/graph-data`

**参数**：

- `file_id`（可选）：文件 ID
- `textbook_id`（可选）：教材 ID
- `max_nodes`（默认 100）：最大节点数

**响应格式**：

```json
{
  "nodes": [
    {
      "id": "知识点名称",
      "label": "知识点名称",
      "level": 3,
      "parent_id": "...",
      "parent_concept": "...",
      "hierarchy_path": "内存管理 > 虚拟内存 > TLB 快表",
      "bloom_level": 3,
      "color": "#fde047",
      "size": 15,
      "shape": "dot",
      "in_degree": 2,
      "out_degree": 1,
      "metadata": {
        "prerequisites": [...],
        "confusion_points": [...],
        "application_scenarios": [...],
        "file_ids": [...]
      }
    }
  ],
  "links": [
    {
      "source": "前置知识点",
      "target": "依赖知识点",
      "relation": "depends_on",
      "label": "依赖"
    }
  ],
  "stats": {
    "total_nodes": 50,
    "total_edges": 30,
    "level_counts": {
      "1": 5,
      "2": 15,
      "3": 30
    }
  }
}
```

### 4. 可视化配置

**节点样式**：

- **Level 1**：星形（star），深蓝色，较大尺寸
- **Level 2**：菱形（diamond），蓝色，中等尺寸
- **Level 3**：圆形（dot），根据 Bloom 层级设置颜色，较小尺寸

**边样式**：

- **父子关系**：蓝色实线，较粗
- **依赖关系**：灰色实线，较细

**Bloom 层级颜色**：

| Level | 名称 | 颜色 |
|-------|------|------|
| 1 | 记忆 | #93c5fd（蓝色） |
| 2 | 理解 | #86efac（绿色） |
| 3 | 应用 | #fde047（黄色） |
| 4 | 分析 | #f97316（橙色） |
| 5 | 评价 | #ef4444（红色） |
| 6 | 创造 | #a855f7（紫色） |

### 5. 节点详情面板

点击节点后显示：

- 知识点名称和层级标签
- 层级路径（hierarchy_path）
- Bloom 层级
- 连接度（入度/出度）
- 父节点
- 前置依赖
- 易错点
- 应用场景

---

## 数据模型

### 1. 知识点节点（knowledge_nodes）

```sql
CREATE TABLE knowledge_nodes (
    node_id TEXT PRIMARY KEY,
    chunk_id INTEGER NOT NULL,
    file_id TEXT NOT NULL,
    core_concept TEXT NOT NULL,
    level INTEGER DEFAULT 3,  -- 1: 一级全局, 2: 二级章节, 3: 三级原子点
    parent_id TEXT,  -- 父节点 ID（用于层级关系）
    prerequisites_json TEXT,  -- JSON 数组（已废弃）
    confusion_points_json TEXT,  -- JSON 数组
    bloom_level INTEGER DEFAULT 3,  -- 1-6
    application_scenarios_json TEXT,  -- JSON 数组
    created_at TEXT DEFAULT (datetime('now'))
);
```

### 2. 知识依赖关系（knowledge_dependencies）

```sql
CREATE TABLE knowledge_dependencies (
    source_node_id TEXT NOT NULL,  -- 前置知识点节点 ID
    target_node_id TEXT NOT NULL,  -- 依赖知识点节点 ID
    dependency_type TEXT DEFAULT 'depends_on',
    created_at TEXT DEFAULT (datetime('now')),
    PRIMARY KEY (source_node_id, target_node_id),
    FOREIGN KEY (source_node_id) REFERENCES knowledge_nodes(node_id),
    FOREIGN KEY (target_node_id) REFERENCES knowledge_nodes(node_id)
);
```

### 3. 数据关系图

```
files (文件)
  ↓
chunks (切片)
  ↓
knowledge_nodes (知识点节点)
  ├── level: 1/2/3 (层级)
  ├── parent_id → knowledge_nodes.node_id (父子关系)
  └── prerequisites_json (已废弃)
  
knowledge_dependencies (依赖关系)
  ├── source_node_id → knowledge_nodes.node_id
  └── target_node_id → knowledge_nodes.node_id
```

---

## API 接口

### 知识提取进度 API

#### 1. 获取知识提取进度（SSE 流式）

**端点**：`GET /api/knowledge-extraction/{file_id}/progress`

**响应类型**：`text/event-stream` (Server-Sent Events)

**响应示例**：

```
data: {"status":"connected","current":5,"total":10,"progress":0.5,"percentage":50.0,"status":"extracting","timestamp":"2024-01-01T12:00:00"}

data: {"current":6,"total":10,"progress":0.6,"percentage":60.0,"status":"extracting","timestamp":"2024-01-01T12:00:05"}

data: {"current":10,"total":10,"progress":1.0,"percentage":100.0,"status":"completed","timestamp":"2024-01-01T12:00:30"}
```

#### 2. 获取知识提取状态（一次性查询）

**端点**：`GET /api/knowledge-extraction/{file_id}/status`

**响应示例**：

```json
{
  "file_id": "xxx",
  "current": 5,
  "total": 10,
  "progress": 0.5,
  "percentage": 50.0,
  "status": "extracting",
  "message": "正在提取知识点: 进程同步... (5/10)",
  "updated_at": "2024-01-01T12:00:00"
}
```

### 知识图谱 API

#### 1. 获取知识图谱数据

**端点**：`GET /api/knowledge-graph/graph-data`

**查询参数**：

- `file_id`（可选）：文件 ID
- `textbook_id`（可选）：教材 ID
- `max_nodes`（默认 100）：最大节点数

**响应**：见 [前端展示流程 - 数据获取 API](#3-数据获取-api)

#### 2. 获取知识点详细信息

**端点**：`GET /api/knowledge-graph/concept/{concept_name}`

**响应示例**：

```json
{
  "concept": "死锁",
  "metadata": {
    "node_id": "...",
    "bloom_level": 3,
    "confusion_points": [...],
    "application_scenarios": [...]
  },
  "prerequisites": ["进程同步", "资源分配"],
  "dependents": ["银行家算法"],
  "in_degree": 2,
  "out_degree": 1
}
```

#### 3. 获取所有知识点列表

**端点**：`GET /api/knowledge-graph/concepts`

**查询参数**：

- `file_id`（可选）：文件 ID
- `textbook_id`（可选）：教材 ID

**响应示例**：

```json
{
  "concepts": ["死锁", "进程同步", "内存管理", ...]
}
```

#### 4. 获取图谱统计信息

**端点**：`GET /api/knowledge-graph/stats`

**响应示例**：

```json
{
  "total_nodes": 100,
  "total_edges": 150,
  "is_dag": true,
  "has_cycles": false,
  "connected_components": 3
}
```

#### 5. 获取知识点关联的题目

**端点**：`GET /api/knowledge-graph/questions/{concept_name}`

**响应示例**：

```json
{
  "concept": "死锁",
  "questions": [
    {
      "question_id": "...",
      "content": "...",
      ...
    }
  ],
  "total": 10
}
```

---

## 总结

### 核心流程总结

1. **知识点提取**：文件上传 → 解析 → 后台异步提取 → 存储到数据库
2. **知识图谱构建**：从数据库加载 → 构建 NetworkX 图 → 建立依赖关系（基于 prerequisites_json 和 knowledge_dependencies 表）
3. **前端展示**：获取图谱数据 → 可视化渲染 → 交互展示

### 关键技术点

- **异步处理**：知识点提取在后台异步进行，不阻塞文件上传
- **进度跟踪**：使用 SSE 流式传输实时进度
- **去重机制**：提取过程中检查重复知识点
- **懒加载机制**：知识图谱采用懒加载，首次查询时自动构建
- **可视化**：使用 vis-network 展示知识图谱

### 扩展方向

1. **知识点合并**：自动合并相似知识点
2. **依赖关系优化**：基于学习路径优化依赖关系
3. **知识图谱分析**：提供更多图谱分析功能（如关键路径、学习顺序推荐）
4. **导出功能**：支持导出知识图谱为多种格式
5. **层级管理**：支持手动或自动管理知识点的层级结构

---

**文档版本**：v1.1  
**最后更新**：2024-12-19  
**维护者**：AI Question Generator Team  
**更新说明**：移除了层级重构和依赖关系构建相关功能

